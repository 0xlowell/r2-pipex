# r2-pipex
# [![lzima's 42 pipex Score](https://badge42.vercel.app/api/v2/cl1nk4f8f004009lb75fyii0c/project/2455829)](https://github.com/JaeSeoKim/badge42)
*Code the Pipex program : the discovery in detail and by programming of a 
UNIX mechanism that you already know.*

Mimic the 'pipe' => | <= command in shell terminal.

Basically: 

* the 'pipe' will read from input files
* use it with 1st command (ex: "ls" command of input file)
* send the result of 1st command(ls result) 
* as input to the 2nd command, use it (ex: "wc" command, of "ls" output)
* then write it in output file

__________________

It should be executed in this way: ```$> ./pipex file1 cmd1 cmd2 file2```

Just in case: *file1* and *file2* are **file names**, *cmd1* and *cmd2* are **shell commands**
with **their parameters**. The execution of the pipex program should do the same
as the next shell command:```$> < file1 cmd1 | cmd2 > file2```

example :

```* $> ./pipex file1 "ls" "wc" file2``` need to be equal to :
```< file1 ls | wc > file2```
__________________
Pipex program:
```
* ./pipex file1 cmd1 cmd2 file2
```
* av[0] = ./pipex (program, as PARENT process)
* av[1] = file1 (READ from this input)
* av[2] = cmd1 (we need connect it to the PATH in our env to launch it, as 1st CHILD process)
* av[3] = cmd2 (we need connect it to the PATH in our env to launch it, as 2nd CHILD process)
* av[4] = files2 (WRITE in this output)

* ac == 5

__________________

## Main

1. Check if there is 5 arguments
2. Use ```open()``` for input file descriptor (fd) and output file descriptor  
```C
open (file1, READ);
open (file2, WRITE);
```
* Stored in *(int)pipex.in* and *(int)pipex.out* 
  
  *pipex.in*  to READ
  
  *pipex.out* to WRITE 

* Standard input (stdin) is by default set at 0, Standard output (stdout) at 1, Standard error (stderr)
3. Check for error about open()
4. Use ```pipe()``` to create 2 fd who will be used for CHILD's process
* fd_pipe[0] to READ fd_pipe[1] to WRITE
5. Get the ```PATH="..."``` from environnement, split it with ```':'```
* You will have a char** with ```char[0] = "/Users/.../bin"```, ```char[1] = "/usr/local/bin"``` redirecting to command already fonctionnal in shell (type "env" in terminal to see PATH line : PATH=/Users/...../.brew/bin:/usr/local/bin:...)
6. Use ```fork()``` for 1st CHILD process: if success, launch ```first_child_process```
* Store PID of fork into a pid_t type (to see PID running on your computer, type ```ps -aux``` in term)
7. Use ```fork()``` for 2st CHILD process: if success, launch ```second_child_process```
* Store PID of fork into a pid_t type (to see PID running on your computer, type ```ps -aux``` in term)
8. Launcher for first_child_process and second_child_process
9. Use ```waitpid()``` with PID of each CHILD process (generated by ```fork()```)
* CHILD process need to be kill before the PARENT process (./pipex)
10. ```free()``` PATH
______________

## first_child_process

* ```close()``` unused => ```close(fd_pipe[0])``` fd_pipe[0] generated by the ```pipe()```*
* ```dup2(fd_pipe[1])``` in stdout, so 1 of ```first_child_process``` 
* *it's duplicated in ```first_child_process```, so close the ```close(fd_pipe[1])```*
* ```dup2(file1)``` in stdin, so 0, to use data from file1 (stored in ```(int)pipex.in``` for me)
* *it's duplicated in ```first_child_process```, so close the ```close(files1)```*
* Get only the ```cmd``` from ```av[2]``` to use it for the PATH (example: ```argv[2] = "ls -l"```, split it with ```' '``` and use only ```argv_splited[0] = "ls"```, it will be used 
* Use this ```cmd``` to join at the end of the ```PATH = /Users/.../bin``` (with ```strjoin()```)
* Use ```access()``` to verified if the ```PATH = /Users/.../bin/ls``` can be executed, return this ```char* = cmd``` if SUCCESS
* Check error : if ```char* = cmd``` is empty, then handle error, ```free()``` and ```exit(127)```
* Use ```execve()``` to execute in stdin(1) the ```"cmd1"```
* ```free()``` PATH
* Handle error with perror(strerror(errno))
* then ```exit(1)``` for SUCCESS

__________________

## second_child_process

Same as the first_child_process, set up to communicate stdout to file2

__________________

## Test

Because "ls" wont use file1 data:

```./pipex file1 cat "say Quackquack. Bonjour forty two. " file2```

This one, wont write in file2 and wont give result of cat, but we give you a surprise. Sound on.

## tips

* error gestion print in stderr 
example: fprintf(stderr, "pipex.cmd1= %s\n", pipex.cmd);

* Shell command
*env*
*ps -aux*

